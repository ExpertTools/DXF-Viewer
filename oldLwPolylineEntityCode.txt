 public Path getInfo(List<String> listIn, List<LayerInfo> layerList, double height, double minX, double minY, double xOffsetIn, double yOffsetIn)
        {
            int numVertices = 0;
            int lineColor = 0;
            double lineThickness = 0;
            double bulge = 0;
            double startAngle, chord, saggita, radius;
            string layerName = "0";
            string lineType = "CONTINUOUS";
            Point lwPoint = new Point();
            Path returnPath = new Path();
            List<Point> lwPolyPoints = new List<Point>();
            Point temp = new Point();
            Point startPoint = new Point();
            Point endPoint = new Point();
            temp = new Point();
            startPoint = new Point();
            endPoint = new Point();
            bool isClosed = false;
            SweepDirection sweepDirection;
            double rotation = 0;

            while (j < listIn.Count)
            {
                if (listIn[j] == "ROTATION")
                {
                    rotation = listIn[++j].ConvertToDoubleWithCulture();
                }
                if (listIn[j] == "OFFSET")
                {
                    xOffsetIn = listIn[++j].ConvertToDoubleWithCulture();
                    yOffsetIn = listIn[++j].ConvertToDoubleWithCulture();
                }
                //The number of vertices in the lwPolyline entity
                if (listIn[j] == " 90")
                {
                    numVertices = Convert.ToInt32(listIn[++j]);
                }
                //This is a boolean value stating whether the polyline is closed or not
                if (listIn[j] == " 70")
                {
                    if (listIn[++j] == "     1")
                        isClosed = true;
                    else
                        isClosed = false;
                }
                //The layer name for the polyline
                if (listIn[j] == "  8")
                {
                    layerName = listIn[++j];
                }
                //This is the x coordinate for the lwpolyline
                if (listIn[j] == " 10")
                {
                    lwPoint.X = listIn[++j].ConvertToDoubleWithCulture();
                }
                //this is the y coordinate for the lwpolyline
                if (listIn[j] == " 20")
                {
                    lwPoint.Y = listIn[++j].ConvertToDoubleWithCulture();
                   //checks if both of the points have a value and if so add them to the list of polyline points
                    if (lwPoint.X != 0 && lwPoint.Y != 0)
                        lwPolyPoints.Add(lwPoint);
                }
                //the line thickness of the polyline
                if (listIn[j] == " 40")
                {
                    lineThickness = listIn[++j].ConvertToDoubleWithCulture();
                }
                //this is the color of the polyline entity
                if (listIn[j] == " 62")
                {
                    lineColor = Convert.ToInt32(listIn[++j]);
                }


                //if there is a bulge(An arc so to speak) it will get that information here
                if (listIn[j] == " 42")
                {
                    //The bulge is 1/4 the Atan of the included angle
                    bulge = listIn[++j].ConvertToDoubleWithCulture();
                    if (bulge > 0)
                        sweepDirection = SweepDirection.Counterclockwise;
                    else
                        sweepDirection = SweepDirection.Clockwise;
                    //finds the start angle from the bulge
                    startAngle = 4 * Math.Atan(bulge);
                    temp = lwPoint;
                    Console.WriteLine("startValueBulge: "+bulge);
                    //then looks for the end point of the bulge to make sure that it uses all the information 
                    while (j <= listIn.Count - 1)
                    {
                        //takes the previous point and assigns it to the start point
                        startPoint = temp;

                        //find the end point and add it to the polylinepoints
                        //For the x point in the polyline
                        if (listIn[j] == " 10")
                        {
                            endPoint.X = listIn[++j].ConvertToDoubleWithCulture();
                            j++;
                        }
                        //For the y point in the polyline
                        if (listIn[j] == " 20")
                        {
                            endPoint.Y = listIn[++j].ConvertToDoubleWithCulture();
                            j++;
                        }
                        //gets the end angle for the bulge
                        

                        if (j >= listIn.Count-1 || listIn[j] == " 42")
                        {

                            
                            //does all the bulge math to calculate the correct values for the bulge, chord, saggita, and radius
                            if (j < listIn.Count - 1)
                            {

                                double endBulge = listIn[++j].ConvertToDoubleWithCulture();
                            }
                            
                            chord = Math.Pow(Math.Pow((endPoint.X - startPoint.X), 2) + Math.Pow((endPoint.Y - startPoint.Y), 2), 0.5);
                            saggita = Math.Abs((chord / 2) * bulge);
                            radius = (Math.Pow(chord / 2, 2) + Math.Pow(saggita, 2)) / (2 * saggita);

                            
                            return buildBulge(startPoint, endPoint, radius, lineType, lineColor, layerName, sweepDirection, lineThickness, layerList, isClosed, height, minX, minY, rotation, xOffsetIn, yOffsetIn);
                            
                            
                        }
                        j++;
                    }

                }
                j++;
            }
            //If there is no bulge it will use this return statement by default
            return buildLWpolyline(lwPolyPoints, lineColor, layerName, lineType, numVertices, lineThickness, layerList, isClosed, height, minX, minY, rotation, xOffsetIn, yOffsetIn);
        }

        /// <summary>
        /// If there is a bulge it will take the information from above and use it to calculate the path of the bulge here
        /// </summary>
        /// <param name="startPoint">the first point of the bulge x and y coordinate</param>
        /// <param name="endPoint">the final point of the bulge x and y coordinate</param>
        /// <param name="radius">the radius of the bulge</param>
        /// <param name="lineType">the type of line that the polyline is during the bulge</param>
        /// <param name="lineColor">the color of the bulge</param>
        /// <param name="layerName">the name of the layer that is to be used to find color and line type later</param>
        /// <param name="lineThickness">the thickness of the polyline</param>
        /// <param name="layerList">The list of layer information such as the line color and line type</param>
        /// <param name="isClosed">Boolean value stating whether or not the polyline is closed</param>
        /// <returns>The path of the bulge to be drawn later</returns>
        public Path buildBulge(Point startPoint, Point endPoint, double radius, string lineType, int lineColor, String layerName, SweepDirection sweepDirectionBool, double lineThickness, List<LayerInfo> layerList, Boolean isClosed, double height, double minX, double minY, double rotation, double xOffset, double yOffset)
        {

            //transform the points to the proper canvas coordinates, using a slightly different method than all the other points
            TransformPoint trans = new TransformPoint();

            startPoint = trans.transformPoint(startPoint, height, minX, minY);
            endPoint = trans.transformPoint(endPoint, height, minX, minY);
                   
            //}
            //else if(startPoint.Y <= endPoint.Y)
            //{
            //    startPoint = trans.transformPoint3(startPoint, height, minX, minY);
            //    endPoint = trans.transformPoint3(endPoint, height, minX, minY);
            //}

            //Creates a new path
            Path path = new Path();

            //Creates a new path Geometry
            PathGeometry arcGeometry = new PathGeometry();

            //Creates a new path figure
            PathFigure pathFigure = new PathFigure();

            //Creates a new arc segment
            ArcSegment arc;// = new ArcSegment();
            
            //Set the radius of the arc (circular arc only for now)
            Size size = new Size();
            size.Height = radius;
            size.Width = radius;

            //if line thickness is 0 sets it to the default size of 0.35
            if (lineThickness == 0.0)
                lineThickness = .2;

            
            //if the bulge is positive it will set the sweep direction to counterclockwis
            //if (endPoint.Y < startPoint.Y)
            //    sweepDirection = SweepDirection.Counterclockwise;
            //if the bulge is less than 0 it will set the sweep direction to clockwise
            //else
            //    sweepDirection = SweepDirection.Clockwise;

            //set the line thickness
            path.StrokeThickness = lineThickness;

            //if the line color has not been set checks the layer information to find line color and line t ype
            if (lineColor == 0)
            {
                foreach (LayerInfo tempLayer in layerList)
                {
                    if (tempLayer.layerName == layerName)
                    {
                        lineColor = tempLayer.lineColor;
                        lineType = tempLayer.lineType;
                    }
                }
            }
            //Sets the color of the polyline dependent on the color it was given either by layer or from the line color above
            ColorSorter cs = new ColorSorter();
            Color color = new Color();
            color = cs.getColor(lineColor);
            Brush tempBrush = new SolidColorBrush(color);
            path.Stroke = tempBrush;


            Console.WriteLine(color);
            Console.WriteLine("Start Point: "+ startPoint);
            Console.WriteLine("End Point: " + endPoint);
            Console.WriteLine("Arc Radius: " + radius);
            //Console.WriteLine(startPoint.Y - endPoint.Y);
            //Console.WriteLine(startPoint.X - endPoint.X);

            //Set the line Type
            SetLineType setLine = new SetLineType();
            path.StrokeDashArray = setLine.setLineType(lineType);
          

            //Sets the arc end point
            //arc.Point = endPoint;

            //Sets the arc start point
            pathFigure.StartPoint = startPoint;
            
            //Makes the path closed if it should be and not if it shouldn't
            pathFigure.IsClosed = isClosed;

            //Sets the arc radius
            //arc.Size = size;
            //arc.SweepDirection = sweepDirectionBool;
            arc = new ArcSegment(endPoint, size, 0, false, sweepDirectionBool, true);
            //Adds the arc to the path figure
            pathFigure.Segments.Add(arc);

            //Adds the path figure to the path geometry
            arcGeometry.Figures.Add(pathFigure);

            //Sets the path equal to the path Geometry
            path.Data = arcGeometry;
            
            //gets the rotation of the line if it is part of a rotated block
            if (rotation != 0)
            {
                Point centerPointForRotate = new Point();
                centerPointForRotate = trans.transformPoint(new Point(xOffset, yOffset), height, minX, minY);
                path.RenderTransform = new RotateTransform(-rotation, centerPointForRotate.X, centerPointForRotate.Y);
            }
            
            return path;
        }

        /// <summary>
        /// Builds the Path of the lwPolyline if there are no bulges
        /// </summary>
        /// <param name="lwPolyPoints">A list of points in x and y coordinates that the polyline will use</param>
        /// <param name="lineColor">The color of the lwPolyline</param>
        /// <param name="layerName">The name of the layer that the lwPolyline is using</param>
        /// <param name="lineType">The type of line that the polyline is drawn as</param>
        /// <param name="numVertices">The number of vertices in this particular lwpolyline</param>
        /// <param name="lineThickness">The thickness of the lwpolyline to be drawn</param>
        /// <param name="layerList">The list of layer information such as line color and line type</param>
        /// <param name="isClosed">Boolean value stating whether the lwpolyline is closed or not</param>
        /// <returns>The path of the lwPolyline if there is no bulge</returns>
        public Path buildLWpolyline(List<Point>lwPolyPoints, int lineColor, string layerName, string lineType, int numVertices, double lineThickness, List<LayerInfo> layerList, Boolean isClosed, double height, double minX, double minY, double rotation, double xOffset, double yOffset)
        {
            Path LwPolyPath = new Path();
            LineSegment line = new LineSegment();
            PathFigure polyFigure = new PathFigure();
            PathGeometry polyPathGeometry = new PathGeometry();
            GeometryGroup lwGroup = new GeometryGroup();
            TransformPoint trans = new TransformPoint();
            Point temp = new Point();
            PathFigureCollection polyCollection = new PathFigureCollection();

            //Determines the start point of the polyline by the first point in the list of points
            polyFigure.StartPoint = trans.transformPoint(lwPolyPoints[0], height, minX, minY);
            
            //Transforms each Point in the lwpolypoints list, and uses those points to add a line segment to the polyline figure
            for (int k= 0; k <= lwPolyPoints.Count - 1; k++)
            {
                temp = trans.transformPoint(lwPolyPoints[k], height, minX, minY);
                line = new LineSegment(temp, true);
                polyFigure.Segments.Add(line);
                
            }

            //Determines if the polyline is closed from the isClosed bool
            polyFigure.IsClosed = isClosed;

            //adds the figure to the collection of polyline figures to be drawn later
            polyCollection.Add(polyFigure);

            //Sets the geometry as the polylineCollection
            polyPathGeometry.Figures = polyCollection;
            
            //if the line thickness is 0 sets it to the default 0.2
            if (lineThickness == 0.0)
                lineThickness = 0.2;

            //If no line color is set it checks the layer information and sets the color and line type dependent on that
            if (lineColor == 0)
            {
                foreach (LayerInfo tempLayer in layerList)
                {
                    if (tempLayer.layerName == layerName)
                    {
                        lineColor = tempLayer.lineColor;
                        lineType = tempLayer.lineType;
                    }
                }
            }

            //Takes the linecolor and sets the paths color to that value
            ColorSorter cs = new ColorSorter();
            Color color = new Color();
            color = cs.getColor(lineColor);
            Brush tempBrush = new SolidColorBrush(color);
            LwPolyPath.Stroke = tempBrush;

            //Sets the stroke thickness
            LwPolyPath.StrokeThickness = lineThickness;
            
            //Sets the data of the path to the geometry
            LwPolyPath.Data = polyPathGeometry;

            //gets the rotation of the line if it is part of a rotated block
            if (rotation != 0)
            {
                Point centerPointForRotate = new Point();
                centerPointForRotate = trans.transformPoint(new Point(xOffset, yOffset), height, minX, minY);
                LwPolyPath.RenderTransform = new RotateTransform(-rotation, centerPointForRotate.X, centerPointForRotate.Y);
            }

            return LwPolyPath;
        }